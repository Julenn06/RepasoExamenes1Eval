â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   ğŸ“š MÃ‰TODOS CLAVE FIREBASE - CRUD COMPLETO                â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  1ï¸âƒ£  CREATE - CREAR UN DOCUMENTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public boolean crear(Alumno alumno) {
    try {
        // 1. Crear referencia a nuevo documento (Firebase genera ID automÃ¡tico)
        DocumentReference docRef = db.collection(COLLECTION).document();
        
        // 2. Asignar el ID generado al objeto alumno
        alumno.setId(docRef.getId());
        
        // 3. Convertir alumno a Map<String, Object> para Firebase
        Map<String, Object> data = alumnoToMap(alumno);
        
        // 4. Guardar datos en Firestore (operaciÃ³n asÃ­ncrona)
        ApiFuture<WriteResult> result = docRef.set(data);
        result.get(); // â† Espera a que se complete la escritura
        
        System.out.println("âœ“ Alumno creado con ID: " + alumno.getId());
        return true;
        
    } catch (Exception e) {
        System.err.println("âœ— Error al crear alumno: " + e.getMessage());
        return false;
    }
}

Para crear usuario :
private Map<String, Object> alumnoToMap(Alumno alumno) {
		Map<String, Object> data = new HashMap<>();
		data.put("id", alumno.getId());
		data.put("nombre", alumno.getNombre());
		data.put("apellidos", alumno.getApellidos());
		data.put("dni", alumno.getDni());
		data.put("email", alumno.getEmail());
		data.put("telefono", alumno.getTelefono());
		data.put("fechaNacimiento", alumno.getFechaNacimiento());
		data.put("direccion", alumno.getDireccion());
		data.put("ciudad", alumno.getCiudad());
		data.put("codigoPostal", alumno.getCodigoPostal());
		data.put("idCurso", alumno.getIdCurso());
		data.put("estado", alumno.getEstado());
		data.put("fechaMatriculacion", alumno.getFechaMatriculacion());
		data.put("notaMedia", alumno.getNotaMedia());
		data.put("creditosAprobados", alumno.getCreditosAprobados());
		return data;
	}

/* CONCEPTOS CLAVE:
   - DocumentReference: Referencia a un documento especÃ­fico
   - .document(): Sin parÃ¡metro = ID automÃ¡tico generado por Firebase
   - .set(data): Crea o sobreescribe el documento completo
   - ApiFuture<WriteResult>: Promesa de que la escritura se completarÃ¡
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  2ï¸âƒ£  READ ALL - LEER TODOS LOS DOCUMENTOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public List<Alumno> leerTodos() {
    List<Alumno> alumnos = new ArrayList<>();
    try {
        // 1. Iniciar consulta para obtener toda la colecciÃ³n
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION).get();
        
        // 2. Esperar y obtener resultado (QuerySnapshot contiene todos los docs)
        QuerySnapshot querySnapshot = future.get();
        
        // 3. Iterar sobre cada documento
        for (QueryDocumentSnapshot doc : querySnapshot.getDocuments()) {
            // 4. Convertir documento a objeto Alumno
            Alumno alumno = mapToAlumno(doc);
            
            if (alumno != null) {
                alumnos.add(alumno);
            }
        }
        
        System.out.println("âœ“ Se encontraron " + alumnos.size() + " alumnos");
        
    } catch (Exception e) {
        System.err.println("âœ— Error al leer alumnos: " + e.getMessage());
    }
    return alumnos;
}

/* CONCEPTOS CLAVE:
   - QuerySnapshot: Resultado de una consulta (mÃºltiples documentos)
   - .getDocuments(): Lista de todos los documentos encontrados
   - QueryDocumentSnapshot: Un documento individual del resultado
   - Devuelve lista vacÃ­a si hay error (no rompe el programa)
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  3ï¸âƒ£  READ BY ID - LEER UN DOCUMENTO ESPECÃFICO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public Alumno leerPorId(String id) {
    try {
        // 1. Obtener referencia al documento especÃ­fico por su ID
        DocumentReference docRef = db.collection(COLLECTION).document(id);
        
        /* ALTERNATIVA (mÃ¡s lenta, no recomendada):
         * DocumentReference docRef = db.collection(COLLECTION)
         *     .whereEqualTo("id", id)
         *     .get().get()
         *     .getDocuments()
         *     .get(0)
         *     .getReference();
         */
        
        // 2. Obtener el documento (operaciÃ³n asÃ­ncrona)
        ApiFuture<DocumentSnapshot> future = docRef.get();
        DocumentSnapshot document = future.get();
        
        // 3. Verificar si el documento existe
        if (document.exists()) {
            // 4. Convertir documento a objeto Alumno
            Alumno alumno = mapToAlumno(document);
            System.out.println("âœ“ Alumno encontrado: " + alumno.getNombreCompleto());
            return alumno;
            
        } else {
            System.out.println("âœ— No se encontrÃ³ alumno con ID: " + id);
        }
        
    } catch (Exception e) {
        System.err.println("âœ— Error al leer alumno: " + e.getMessage());
    }
    return null;
}

/* CONCEPTOS CLAVE:
   - DocumentSnapshot: Un Ãºnico documento (puede existir o no)
   - .document(id): Acceso directo por ID del documento
   - .exists(): Verifica si el documento existe en Firestore
   - DocumentReference vs DocumentSnapshot:
     * Reference = direcciÃ³n/puntero al documento
     * Snapshot = contenido real del documento
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  4ï¸âƒ£  UPDATE - ACTUALIZAR UN DOCUMENTO EXISTENTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public boolean actualizar(Alumno alumno) {
    try {
        // 1. Obtener referencia al documento existente
        DocumentReference docRef = db.collection(COLLECTION).document(alumno.getId());
        
        // 2. Convertir alumno actualizado a Map
        Map<String, Object> data = alumnoToMap(alumno);
        
        // 3. Actualizar solo los campos especificados (no sobrescribe todo)
        ApiFuture<WriteResult> result = docRef.update(data);
        result.get(); // â† Espera a que se complete la actualizaciÃ³n
        
        System.out.println("âœ“ Alumno actualizado: " + alumno.getNombreCompleto());
        return true;
        
    } catch (Exception e) {
        System.err.println("âœ— Error al actualizar alumno: " + e.getMessage());
        return false;
    }
}

/* CONCEPTOS CLAVE:
   - .update(data): Actualiza campos especÃ­ficos (mantiene otros campos)
   - .set(data): Sobrescribe el documento completo
   - Diferencia update vs set:
     * update: Solo modifica campos enviados
     * set: Reemplaza todo el documento (borra campos no enviados)
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  5ï¸âƒ£  DELETE - ELIMINAR UN DOCUMENTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public boolean eliminar(String id) {
    try {
        // 1. Eliminar documento directamente por ID
        ApiFuture<WriteResult> result = db.collection(COLLECTION).document(id).delete();
        result.get(); // â† Espera a que se complete la eliminaciÃ³n
        
        System.out.println("âœ“ Alumno eliminado con ID: " + id);
        return true;
        
    } catch (Exception e) {
        System.err.println("âœ— Error al eliminar alumno: " + e.getMessage());
        return false;
    }
}

/* CONCEPTOS CLAVE:
   - .delete(): Elimina el documento completo
   - No lanza error si el documento no existe
   - Las subcolecciones NO se eliminan automÃ¡ticamente
   - WriteResult contiene el timestamp de la operaciÃ³n
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ“Š RESUMEN DE OPERACIONES FIREBASE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERACIÃ“N   â”‚ MÃ‰TODO FIREBASE          â”‚ TIPO DE FUTURE                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CREATE      â”‚ docRef.set(data)         â”‚ ApiFuture<WriteResult>         â”‚
â”‚ READ ALL    â”‚ collection.get()         â”‚ ApiFuture<QuerySnapshot>       â”‚
â”‚ READ BY ID  â”‚ document(id).get()       â”‚ ApiFuture<DocumentSnapshot>    â”‚
â”‚ UPDATE      â”‚ docRef.update(data)      â”‚ ApiFuture<WriteResult>         â”‚
â”‚ DELETE      â”‚ document(id).delete()    â”‚ ApiFuture<WriteResult>         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ”‘ DIFERENCIAS CLAVE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“¦ QuerySnapshot vs DocumentSnapshot
â”œâ”€ QuerySnapshot:  Resultado de consulta (mÃºltiples documentos)
â”‚  â””â”€ MÃ©todos: .getDocuments(), .size(), .isEmpty()
â”‚
â””â”€ DocumentSnapshot: Un Ãºnico documento
   â””â”€ MÃ©todos: .exists(), .getData(), .getString(), .getLong()

ğŸ”— DocumentReference vs DocumentSnapshot
â”œâ”€ DocumentReference: "DirecciÃ³n" del documento (puntero)
â”‚  â””â”€ MÃ©todos: .get(), .set(), .update(), .delete()
â”‚
â””â”€ DocumentSnapshot: "Contenido" del documento (datos)
   â””â”€ MÃ©todos: .exists(), .getData(), .toObject()

â³ ApiFuture Pattern
â”œâ”€ 1. ApiFuture<T> future = operaciÃ³n();  // Inicia operaciÃ³n asÃ­ncrona
â””â”€ 2. T resultado = future.get();         // Espera y obtiene resultado

ğŸ“ .set() vs .update()
â”œâ”€ .set(data):    Sobrescribe TODO el documento
â””â”€ .update(data): Solo actualiza campos especificados


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  6ï¸âƒ£  READ WITH FILTER - LEER CON FILTROS (WHERE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public List<Alumno> buscarPorEdad(int edad) {
    List<Alumno> alumnos = new ArrayList<>();
    try {
        // 1. Aplicar filtro .whereEqualTo() a la consulta
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION)
            .whereEqualTo("edad", edad)
            .get();
        
        QuerySnapshot querySnapshot = future.get();
        
        // 2. Procesar documentos que coinciden con el filtro
        for (QueryDocumentSnapshot doc : querySnapshot.getDocuments()) {
            Alumno alumno = mapToAlumno(doc);
            if (alumno != null) {
                alumnos.add(alumno);
            }
        }
        
        System.out.println("âœ“ Se encontraron " + alumnos.size() + " alumnos con edad " + edad);
        
    } catch (Exception e) {
        System.err.println("âœ— Error al buscar alumnos: " + e.getMessage());
    }
    return alumnos;
}

/* OPERADORES DE FILTRO DISPONIBLES:
   - .whereEqualTo("campo", valor)           â†’ campo == valor
   - .whereNotEqualTo("campo", valor)        â†’ campo != valor
   - .whereGreaterThan("campo", valor)       â†’ campo > valor
   - .whereGreaterThanOrEqualTo("campo", v)  â†’ campo >= valor
   - .whereLessThan("campo", valor)          â†’ campo < valor
   - .whereLessThanOrEqualTo("campo", v)     â†’ campo <= valor
   - .whereIn("campo", lista)                â†’ campo IN [val1, val2, ...]
   - .whereArrayContains("campo", valor)     â†’ array contiene valor
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  7ï¸âƒ£  READ WITH MULTIPLE FILTERS - CONSULTAS COMPUESTAS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public List<Alumno> buscarPorEdadYCurso(int edadMin, int edadMax, String curso) {
    List<Alumno> alumnos = new ArrayList<>();
    try {
        // 1. Combinar mÃºltiples filtros
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION)
            .whereGreaterThanOrEqualTo("edad", edadMin)
            .whereLessThanOrEqualTo("edad", edadMax)
            .whereEqualTo("curso", curso)
            .get();
        
        QuerySnapshot querySnapshot = future.get();
        
        for (QueryDocumentSnapshot doc : querySnapshot.getDocuments()) {
            Alumno alumno = mapToAlumno(doc);
            if (alumno != null) {
                alumnos.add(alumno);
            }
        }
        
        System.out.println("âœ“ " + alumnos.size() + " alumnos entre " + edadMin + 
                          "-" + edadMax + " aÃ±os en " + curso);
        
    } catch (Exception e) {
        System.err.println("âœ— Error: " + e.getMessage());
    }
    return alumnos;
}

/* IMPORTANTE:
   - Puedes combinar mÃºltiples filtros en una consulta
   - Firestore requiere ÃNDICES para algunas combinaciones complejas
   - LÃ­mite: No puedes usar != y < > en campos diferentes
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  8ï¸âƒ£  READ WITH ORDERING - ORDENAR RESULTADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public List<Alumno> leerOrdenadosPorNombre() {
    List<Alumno> alumnos = new ArrayList<>();
    try {
        // 1. Ordenar resultados con .orderBy()
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION)
            .orderBy("nombreCompleto", Query.Direction.ASCENDING)  // A-Z
            .get();
        
        QuerySnapshot querySnapshot = future.get();
        
        for (QueryDocumentSnapshot doc : querySnapshot.getDocuments()) {
            Alumno alumno = mapToAlumno(doc);
            if (alumno != null) {
                alumnos.add(alumno);
            }
        }
        
        System.out.println("âœ“ " + alumnos.size() + " alumnos ordenados alfabÃ©ticamente");
        
    } catch (Exception e) {
        System.err.println("âœ— Error: " + e.getMessage());
    }
    return alumnos;
}

/* OPCIONES DE ORDENAMIENTO:
   - Query.Direction.ASCENDING   â†’ Orden ascendente (A-Z, 0-9)
   - Query.Direction.DESCENDING  â†’ Orden descendente (Z-A, 9-0)
   - Puedes ordenar por mÃºltiples campos: .orderBy("edad").orderBy("nombre")
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  9ï¸âƒ£  READ WITH LIMIT - LIMITAR RESULTADOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public List<Alumno> obtenerUltimosN(int cantidad) {
    List<Alumno> alumnos = new ArrayList<>();
    try {
        // 1. Limitar nÃºmero de resultados con .limit()
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION)
            .orderBy("fechaInscripcion", Query.Direction.DESCENDING)
            .limit(cantidad)
            .get();
        
        QuerySnapshot querySnapshot = future.get();
        
        for (QueryDocumentSnapshot doc : querySnapshot.getDocuments()) {
            Alumno alumno = mapToAlumno(doc);
            if (alumno != null) {
                alumnos.add(alumno);
            }
        }
        
        System.out.println("âœ“ Ãšltimos " + alumnos.size() + " alumnos registrados");
        
    } catch (Exception e) {
        System.err.println("âœ— Error: " + e.getMessage());
    }
    return alumnos;
}

/* CONCEPTOS:
   - .limit(n): Devuelve mÃ¡ximo n documentos
   - Ãštil para paginaciÃ³n
   - Combinar con .orderBy() para resultados consistentes
   - .limitToLast(n): Ãšltimos n documentos (requiere orderBy)
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ”Ÿ  BATCH WRITE - OPERACIONES EN LOTE
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public boolean crearMultiples(List<Alumno> alumnos) {
    try {
        // 1. Crear un batch (agrupa mÃºltiples operaciones)
        WriteBatch batch = db.batch();
        
        // 2. Agregar todas las operaciones al batch
        for (Alumno alumno : alumnos) {
            DocumentReference docRef = db.collection(COLLECTION).document();
            alumno.setId(docRef.getId());
            
            Map<String, Object> data = alumnoToMap(alumno);
            batch.set(docRef, data);  // â† Agregar al batch (no ejecuta todavÃ­a)
        }
        
        // 3. Ejecutar todas las operaciones de una vez (atÃ³mico)
        ApiFuture<List<WriteResult>> future = batch.commit();
        future.get();
        
        System.out.println("âœ“ " + alumnos.size() + " alumnos creados en lote");
        return true;
        
    } catch (Exception e) {
        System.err.println("âœ— Error en batch: " + e.getMessage());
        return false;
    }
}

/* VENTAJAS DE BATCH:
   - OperaciÃ³n ATÃ“MICA: Todo se ejecuta o nada
   - MÃ¡s eficiente que operaciones individuales
   - Reduce latencia de red
   - LÃ­mite: MÃ¡ximo 500 operaciones por batch
   - Operaciones soportadas: set(), update(), delete()
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  1ï¸âƒ£1ï¸âƒ£  COUNT - CONTAR DOCUMENTOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public int contarAlumnos() {
    try {
        // OPCIÃ“N 1: Obtener documentos y contar (menos eficiente)
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION).get();
        QuerySnapshot querySnapshot = future.get();
        
        int count = querySnapshot.size();
        System.out.println("âœ“ Total de alumnos: " + count);
        return count;
        
    } catch (Exception e) {
        System.err.println("âœ— Error al contar: " + e.getMessage());
        return 0;
    }
}

public int contarAlumnosPorCurso(String curso) {
    try {
        // OPCIÃ“N 2: Contar con filtro
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION)
            .whereEqualTo("curso", curso)
            .get();
        
        QuerySnapshot querySnapshot = future.get();
        int count = querySnapshot.size();
        
        System.out.println("âœ“ Alumnos en " + curso + ": " + count);
        return count;
        
    } catch (Exception e) {
        System.err.println("âœ— Error: " + e.getMessage());
        return 0;
    }
}

/* NOTA:
   - Firebase NO tiene mÃ©todo .count() directo
   - Debes obtener documentos y usar .size()
   - Para grandes colecciones, considera mantener un contador separado
   - Firestore cobra por documento leÃ­do, incluso al contar
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  1ï¸âƒ£2ï¸âƒ£  TRANSACTION - OPERACIONES TRANSACCIONALES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public boolean transferirPuntos(String alumnoIdOrigen, String alumnoIdDestino, int puntos) {
    try {
        // 1. Ejecutar operaciÃ³n dentro de una transacciÃ³n
        ApiFuture<String> transaction = db.runTransaction(trans -> {
            // 2. Leer documentos dentro de la transacciÃ³n
            DocumentReference origenRef = db.collection(COLLECTION).document(alumnoIdOrigen);
            DocumentReference destinoRef = db.collection(COLLECTION).document(alumnoIdDestino);
            
            DocumentSnapshot origenDoc = trans.get(origenRef).get();
            DocumentSnapshot destinoDoc = trans.get(destinoRef).get();
            
            // 3. Validar y calcular nuevos valores
            Long puntosOrigen = origenDoc.getLong("puntos");
            Long puntosDestino = destinoDoc.getLong("puntos");
            
            if (puntosOrigen == null || puntosOrigen < puntos) {
                throw new Exception("Puntos insuficientes");
            }
            
            // 4. Escribir cambios (se ejecutan automÃ¡ticamente si todo OK)
            trans.update(origenRef, "puntos", puntosOrigen - puntos);
            trans.update(destinoRef, "puntos", puntosDestino + puntos);
            
            return "Transferencia exitosa";
        });
        
        String result = transaction.get();
        System.out.println("âœ“ " + result);
        return true;
        
    } catch (Exception e) {
        System.err.println("âœ— Error en transacciÃ³n: " + e.getMessage());
        return false;
    }
}

/* TRANSACCIONES:
   - ATOMICIDAD: Todo se ejecuta o nada (rollback automÃ¡tico si falla)
   - CONSISTENCIA: Los datos siempre quedan en estado vÃ¡lido
   - AISLAMIENTO: Otras operaciones no ven cambios hasta commit
   - Ideal para: transferencias, contadores, operaciones dependientes
   - Firestore reintenta automÃ¡ticamente si hay conflictos
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  1ï¸âƒ£3ï¸âƒ£  CHECK EXISTS - VERIFICAR SI EXISTE DOCUMENTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

public boolean existeAlumno(String id) {
    try {
        DocumentReference docRef = db.collection(COLLECTION).document(id);
        ApiFuture<DocumentSnapshot> future = docRef.get();
        DocumentSnapshot document = future.get();
        
        boolean existe = document.exists();
        
        if (existe) {
            System.out.println("âœ“ El alumno existe");
        } else {
            System.out.println("âœ— El alumno NO existe");
        }
        
        return existe;
        
    } catch (Exception e) {
        System.err.println("âœ— Error: " + e.getMessage());
        return false;
    }
}

public boolean existeAlumnoPorEmail(String email) {
    try {
        // Verificar existencia por campo Ãºnico (no por ID)
        ApiFuture<QuerySnapshot> future = db.collection(COLLECTION)
            .whereEqualTo("email", email)
            .limit(1)  // Solo necesitamos saber si existe 1
            .get();
        
        QuerySnapshot querySnapshot = future.get();
        boolean existe = !querySnapshot.isEmpty();
        
        System.out.println(existe ? "âœ“ Email ya registrado" : "âœ— Email disponible");
        return existe;
        
    } catch (Exception e) {
        System.err.println("âœ— Error: " + e.getMessage());
        return false;
    }
}

/* CASOS DE USO:
   - Validar antes de crear (evitar duplicados)
   - Verificar permisos/acceso
   - Comprobar relaciones entre documentos
   - .exists() es mÃ¡s eficiente que obtener todos los datos
*/


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ“Š TABLA RESUMEN AMPLIADA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OPERACIÃ“N      â”‚ MÃ‰TODO FIREBASE              â”‚ TIPO FUTURE              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CREATE         â”‚ docRef.set(data)             â”‚ ApiFuture<WriteResult>   â”‚
â”‚ READ ALL       â”‚ collection.get()             â”‚ ApiFuture<QuerySnapshot> â”‚
â”‚ READ BY ID     â”‚ document(id).get()           â”‚ ApiFuture<DocSnapshot>   â”‚
â”‚ UPDATE         â”‚ docRef.update(data)          â”‚ ApiFuture<WriteResult>   â”‚
â”‚ DELETE         â”‚ document(id).delete()        â”‚ ApiFuture<WriteResult>   â”‚
â”‚ FILTER         â”‚ .whereEqualTo().get()        â”‚ ApiFuture<QuerySnapshot> â”‚
â”‚ ORDER BY       â”‚ .orderBy(campo).get()        â”‚ ApiFuture<QuerySnapshot> â”‚
â”‚ LIMIT          â”‚ .limit(n).get()              â”‚ ApiFuture<QuerySnapshot> â”‚
â”‚ BATCH          â”‚ batch.commit()               â”‚ ApiFuture<List<Write>>   â”‚
â”‚ COUNT          â”‚ querySnapshot.size()         â”‚ int                      â”‚
â”‚ TRANSACTION    â”‚ db.runTransaction()          â”‚ ApiFuture<T>             â”‚
â”‚ EXISTS         â”‚ document.exists()            â”‚ boolean                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  âš ï¸  MANEJO DE ERRORES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âœ… PATRÃ“N RECOMENDADO:
try {
    ApiFuture<T> future = operaciÃ³n();
    T resultado = future.get(); // Puede lanzar InterruptedException, ExecutionException
    
    // Procesar resultado...
    
} catch (Exception e) {
    System.err.println("âœ— Error: " + e.getMessage());
    // Devolver valor por defecto (null, false, lista vacÃ­a, etc.)
}

âŒ EVITAR:
- Propagar excepciones con throws (peor experiencia usuario)
- Hacer .get().get() sin separar (difÃ­cil de leer)
- No validar .exists() antes de acceder a documento


â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  ğŸ“š RECURSOS ADICIONALES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Firebase Admin SDK: https://firebase.google.com/docs/admin/setup
Firestore Java API: https://googleapis.dev/java/google-cloud-firestore/latest/
Query Examples: https://firebase.google.com/docs/firestore/query-data/queries